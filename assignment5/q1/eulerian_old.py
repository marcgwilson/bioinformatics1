#!/usr/bin/python
import sys


# Returns a dictionary of edges
# key = starting node
# value = list of terminal nodes
def build_node_dict(data):
    nodes = {}
    for d in data:
        d = d.strip()
        if 'Output' in d:
            break
        else:
            node_data = d.split(' -> ')

            s = int(node_data[0])
            ts = node_data[1].split(',')

            nodes[s] = map(int, ts)
    return nodes


# returns a list of starting nodes with odd degree
# this is the list of nodes we should start with when building a Eulerian path
# data is a dictionary generated by build_node_dict
def odd_degrees(data):
    nodes = {}

    for k in data:
        # Determine the degree of the starting nodes
        if k not in nodes:
            nodes[k] = len(data[k])
        else:
            nodes[k] = nodes[k] + len(data[k])
        # Determine the degree of the ending nodes
        for n in data[k]:
            if n not in nodes:
                nodes[n] = 1
            else:
                nodes[n] = nodes[n] + 1

    return dict((k, nodes[k]) for k in nodes if nodes[k] % 2 == 1)


def build_node_list(data):
    nodes = []
    for d in data:
        d = d.strip()
        if 'Output' in d:
            break
        else:
            node_data = d.split(' -> ')

            s = int(node_data[0])
            ts = node_data[1].split(',')

            for t in ts:
                nodes.append((s, int(t)))

    return nodes

def find_eulerian_tour(graph):
    tour=[]
    find_tour(graph[0][0],graph,tour)
    return tour


def find_tour(u,E,tour): 
  for (a,b) in E:
    if a==u:
        E.remove((a,b))
        find_tour(b,E,tour)
    elif b==u:
        E.remove((a,b))
        find_tour(a,E,tour)
  tour.insert(0,u)


from collections import defaultdict

def find_euler_tour_2(graph):
    tour = []
    E = graph

    numEdges = defaultdict(int)

    def find_tour_2(u):
        for e in E:
            if u == e[0]:
                u,v = e
                E.remove(e)
                find_tour_2(v)
            elif u == e[1]:
                v,u = e
                E.remove(e)
                find_tour_2(v)
        tour.insert(0,u)

    for i,j in graph:
        numEdges[i] += 1
        numEdges[j] += 1

    start = graph[0][0]
    for i,j in numEdges.iteritems():
        if j % 2 > 0:
            start = i
            break

    current = start
    find_tour_2(current)

    if tour[0] != tour[-1]:
        return None
    return tour


def find_eulerian_tour_3(graph):
             
    def freqencies():
        my_list = [x for (x, y) in graph]
        result = [0 for i in range(max(my_list) + 1)]
        for i in my_list:
            result[i] += 1
        return result
         
    def find_node(tour):
        for i in tour:
            if freq[i] != 0:
                return i
        return -1
     
    def helper(tour, next):
        find_path(tour, next)
        u = find_node(tour)
        while sum(freq) != 0:     
            sub = find_path([], u)
            tour = tour[:tour.index(u)] + sub + tour[tour.index(u) + 1:]  
            u = find_node(tour)
        return tour
                  
    def find_path(tour, next):
        for (x, y) in graph:
            if x == next:
                current = graph.pop(graph.index((x,y)))
                graph.pop(graph.index((current[1], current[0])))
                tour.append(current[0])
                freq[current[0]] -= 1
                freq[current[1]] -= 1
                return find_path(tour, current[1])
        tour.append(next)
        return tour             
              
    graph += [(y, x) for (x, y) in graph]
    freq = freqencies()   
    return helper([], graph[0][0])


def main():
    # The DNA(?) string to parse
    data_file = open(sys.argv[1], 'r')
    data = data_file.readlines()

    edges = build_node_dict(data[1:])
    degrees = odd_degrees(edges)

    print 'degrees: %s' % degrees

    edges_list = edges.items()

    edges_list_2 = build_node_list(data[1:])
    edges_list_3 = build_node_list(data[1:])
    edges_list_4 = build_node_list(data[1:])

    print 'edges_list_2: %s' % edges_list_2
    print 'edges_list: %s' % edges_list

    tour = find_eulerian_tour(edges_list_2)
    tour_2 = find_euler_tour_2(edges_list_3)
    tour_3 = find_eulerian_tour_3(edges_list_4)

    print 'tour: %s' % tour
    print 'tour_2: %s' % tour_2
    print 'tour_3: %s' % tour_3
    # key, value = edges_list[0]

    # # If there's only one edge for this starting node, remove the key
    # # Otherwise, just remove this particular edge
    # if len(value) == 1:
    #     edges.pop(key)
    # else:
    #     edges[key] = value[1:]

    # path = [[key, value[0]]]

    # index = 0
    # while len(edges) is not 0:
    #     key = path[index][1] # The key we're looking for is the second element in list of length 2 that represents our edge.
    #     # Now find the next edge to add to our path

    #     if key in edges:
    #         value = edges[key]
    #         path.insert(int(index + 1), [int(key), int(value[0])])
    #         if len(value) == 1:
    #             edges.pop(key)
    #         else:
    #             edges[key] = value[1:]
    #         index+=1
    #     else:
    #         for i in range(len(path)):
    #             p = path[i]
    #             key = p[1] # Use the value as the key we're looking for
    #             if key in edges:
    #                 value = edges[key]
    #                 if len(value) == 1:
    #                     edges.pop(key)
    #                 else:
    #                     edges[key] = value[1:]
    #                 path.insert(i + 1, [key, value[0]])
    #                 index = i + 1


    # # Give result an initial value, then iterate over the edges and append p[1]
    # result = [str(path[0][0])]

    # for p in path:
    #     result.append(str(p[1]))

    # output = '->'.join(result)
    # print output


if __name__ == "__main__":
    main()